<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Hypergeometric</title><style type="text/css">body{
margin:40px auto;
max-width:650px;
line-height:1.6;
font-size:18px;
color:#eee;
background-color:#111;
padding:0 10px
}
textarea, input, button, select {
color:#eee;
background-color:#111;
}
button:hover {
  background-color:#222;
}
label {
  margin-left: 0.5em;
  margin-right: 1em;
}
</style>
  <script type="text/javascript" src="vis-graph3d.min.js"></script>
  <script type="text/javascript" src="hypergeometric.js"></script>
</head>

<body>
  <div id="root"></div>
</body>

<script type="text/javascript">
  const STYLES = ['surface', 'bar', /*'bar-color',*/ 'bar-size', 'dot', 'dot-line', /*'dot-color',*/ 'dot-size', 'line', 'grid'];

  const root = document.getElementById("root");

  const tempGlobal = {
    // graph stuff
    data: null,
    graph: null,
    // table stuff
    tableContainer: null
  };

  /** @type {(s: string, n: number) => string} */
  const repeatString = (s, n) => {
    let output = "";

    for (let i = 0; i < n; i += 1) {
      output += s;
    }

    return output
  }

  const PROB_ZERO = "0." + repeatString("0", Hypergeometric.PMF_DIGITS);
  const PROB_ZERO_PLUS_EPILISON = "0." + repeatString("0", Hypergeometric.PMF_DIGITS - 2) + "+Îµ";
  const PROB_ROUND_TO_1_THRESHOLD = parseFloat("0." + repeatString("9", Hypergeometric.PMF_DIGITS - 1) + "5");
  const probabiltyToString = (probability) => {
    const pString = probability.toFixed(Hypergeometric.PMF_DIGITS);
    return probability === 0
      ? "0"
      : probability > PROB_ROUND_TO_1_THRESHOLD
        ? "1"
        : pString === PROB_ZERO ? PROB_ZERO_PLUS_EPILISON : pString;
  };

  const renderRows = ({rows, yMax, options}) => {
    //
    // Render graph
    //

    // Create and populate a data table.
    const data = new vis.DataSet();

    var counter = 0;
    for (var i = 0; i < rows.length; i+=1) {
      const {successesInPop, observedSuccesses, probability} = rows[i];
      const value = observedSuccesses/yMax;
      data.add({
        id: counter++,
        x: successesInPop,
        y: observedSuccesses,
        z: probability,
        style: value,
      });
    }
    // avoid "Graph data is not initialized" errors
    if (!rows.length) {
      data.add({
        id: counter++,
        x: 0,
        y: 0,
        z: 0,
        style: 0,
      });
    }

    if (!tempGlobal.data) {
      tempGlobal.data = data;

      // Instantiate our graph object.
      const container = document.createElement('div');
      root.appendChild(container);
      tempGlobal.graph = new vis.Graph3d(
        container,
        tempGlobal.data,
        {
          width:  '1024px',
          height: '768px',
          style: 'surface',
          showPerspective: true,
          showGrid: true,
          showShadow: false,
          keepAspectRatio: true,
          verticalRatio: 0.5,
          xLabel: "success states in pop",
          yLabel: "observed successes",
        }
      );
    } else {
      tempGlobal.data = data;
      tempGlobal.graph.setData(tempGlobal.data);
    }

    if (options) {
      tempGlobal.graph.setOptions(options);
    }

    //
    // Render tables
    //

    if (!tempGlobal.tableContainer) {
      tempGlobal.tableContainer = document.createElement('div');

      root.appendChild(tempGlobal.tableContainer);
    } else {
      tempGlobal.tableContainer.innerHTML = "";
    }

    // Render individual probabilty table
    (() => {
      const individualDetails = document.createElement("details");

      const individualSummary = document.createElement("summary");
      individualSummary.textContent = "individual probabilty table";
      individualDetails.appendChild(individualSummary);

      const individualTable = document.createElement("table");

      const headerRow = document.createElement("tr");

      const successesInPopH = document.createElement("th");
      successesInPopH.textContent = "successesInPop";
      headerRow.appendChild(successesInPopH);

      const observedSuccessesH = document.createElement("th");
      observedSuccessesH.textContent = "observedSuccesses";
      headerRow.appendChild(observedSuccessesH);

      const probabilityH = document.createElement("th");
      probabilityH.textContent = "probability";
      headerRow.appendChild(probabilityH);

      individualTable.appendChild(headerRow);

      for (let i = 0; i < rows.length; i += 1) {
          const {successesInPop, observedSuccesses, probability} = rows[i];
          const dataRow = document.createElement("tr");

          const successesInPopD = document.createElement("td");
          successesInPopD.textContent = successesInPop;
          dataRow.appendChild(successesInPopD);

          const observedSuccessesD = document.createElement("td");
          observedSuccessesD.textContent = observedSuccesses;
          dataRow.appendChild(observedSuccessesD);

          const probabilityD = document.createElement("td");
          probabilityD.textContent = probabiltyToString(probability);
          dataRow.appendChild(probabilityD);

          individualTable.appendChild(dataRow);
      }

      individualDetails.appendChild(individualTable);

      tempGlobal.tableContainer.appendChild(individualDetails);
    })();

    // Render "at-least" probabilty table
    (() => {
      const atLeastDetails = document.createElement("details");

      const atLeastSummary = document.createElement("summary");
      atLeastSummary.textContent = "at-least probabilty table";
      atLeastDetails.appendChild(atLeastSummary);

      const atLeastTable = document.createElement("table");

      const headerRow = document.createElement("tr");

      const successesInPopH = document.createElement("th");
      successesInPopH.textContent = "successesInPop";
      headerRow.appendChild(successesInPopH);

      const observedSuccessesH = document.createElement("th");
      observedSuccessesH.textContent = "observedSuccesses";
      headerRow.appendChild(observedSuccessesH);

      const probabilityH = document.createElement("th");
      probabilityH.textContent = "probability";
      headerRow.appendChild(probabilityH);

      atLeastTable.appendChild(headerRow);

      const atLeastRows = []
      for (let i = 0; i < rows.length; i += 1) {
        const {successesInPop, observedSuccesses, probability} = rows[i];
        let probabilitySum = 0;
        // TODO something better than O(n^2) if/when we care
        for (let prevI = 0; prevI < rows.length; prevI += 1) {
          const other = rows[prevI];
          if (
            other.successesInPop === successesInPop
            && other.observedSuccesses >= observedSuccesses
          ) {
            probabilitySum += other.probability;
          }
        }

        atLeastRows.push({successesInPop, observedSuccesses, probability: probabilitySum});
      }

      for (let i = 0; i < atLeastRows.length; i += 1) {
          const {successesInPop, observedSuccesses, probability} = atLeastRows[i];
          const dataRow = document.createElement("tr");

          const successesInPopD = document.createElement("td");
          successesInPopD.textContent = successesInPop;
          dataRow.appendChild(successesInPopD);

          const observedSuccessesD = document.createElement("td");
          observedSuccessesD.textContent = observedSuccesses;
          dataRow.appendChild(observedSuccessesD);

          const probabilityD = document.createElement("td");
          probabilityD.textContent = probabiltyToString(probability);
          dataRow.appendChild(probabilityD);

          atLeastTable.appendChild(dataRow);
      }

      atLeastDetails.appendChild(atLeastTable);

      tempGlobal.tableContainer.appendChild(atLeastDetails);
    })();
  };

  const chartControls = document.createElement("form");

  const POPULATION_DEFAULT = 60;
  const populationInput = document.createElement("input");
  populationInput.type = "number";
  populationInput.id = "population-input";
  populationInput.value = POPULATION_DEFAULT;
  chartControls.appendChild(populationInput);

  const populationLabel = document.createElement("label");
  populationLabel.htmlFor = "population-input";
  populationLabel.innerHTML = "Population";
  chartControls.appendChild(populationLabel);

  const DRAWS_DEFAULT = 7;
  const drawsInput = document.createElement("input");
  drawsInput.type = "number";
  drawsInput.id = "draws-input";
  drawsInput.value = DRAWS_DEFAULT;
  chartControls.appendChild(drawsInput);

  const drawsLabel = document.createElement("label");
  drawsLabel.htmlFor = "draws-input";
  drawsLabel.innerHTML = "Draws";
  chartControls.appendChild(drawsLabel);

  const styleSelect = document.createElement("select");
  for (let i = 0; i < STYLES.length; i += 1) {
    const option = document.createElement("option")
    option.value = STYLES[i];
    option.textContent = STYLES[i];
    option.selected = i === 0;
    styleSelect.appendChild(option);
  }
  chartControls.appendChild(styleSelect);

  const render = () => {
    var axisStep = 1;

    let popMax = parseInt(populationInput.value, 10);
    if (isNaN(popMax)) {
      popMax = POPULATION_DEFAULT;
    }

    let draws = parseInt(drawsInput.value, 10);
    if (isNaN(draws)) {
      draws = DRAWS_DEFAULT;
    }

    const rows = [];

    for (var successesInPop = 0; successesInPop <= popMax; successesInPop += axisStep) {
      for (var observedSuccesses = 0; observedSuccesses <= draws; observedSuccesses += axisStep) {
        if (observedSuccesses > popMax || observedSuccesses > successesInPop) { continue }

        const probability = Hypergeometric.pmf(popMax, successesInPop, draws, observedSuccesses);
        rows.push({successesInPop, observedSuccesses, probability});
      }
    }

    renderRows({rows, yMax: draws, options: {style: styleSelect.value || STYLES[0]}});
  };

  chartControls.addEventListener("change", render);

  root.appendChild(chartControls);

  render();

  const CLASS_INDEX_KEY = "class-index-key";

  const CLASS_ENTRIES_KEYS = ["class-entries-key-0", "class-entries-key-1", "class-entries-key-2", "class-entries-key-3", "class-entries-key-4"];

  const loadClassEntriesIndex = () => {
    let index = window.localStorage.getItem(CLASS_INDEX_KEY);
    if (typeof index === "string") {
        index = JSON.parse(index)
    }
    if (typeof index !== "number") {
        index = 0
        window.localStorage.setItem(CLASS_INDEX_KEY, index)
    }

    return index
  };

  const syncClassEntries = () => {
    //
    // Save to local storage
    //

    let index = loadClassEntriesIndex();

    index += 1;
    index %= CLASS_ENTRIES_KEYS.length;

    window.localStorage.setItem(CLASS_ENTRIES_KEYS[index], JSON.stringify(classEntries))
    window.localStorage.setItem(CLASS_INDEX_KEY, index);

    resetClassControls();
  };

  const loadClassEntriesOrDefault = () => {
    const index = loadClassEntriesIndex();

    const parsed = JSON.parse(window.localStorage.getItem(CLASS_ENTRIES_KEYS[index]))

    if (parsed) {
        return parsed
    } else {
        return [
          { amount: defaultAmountForIndex(0), label: defaultLabelForIndex(0) },
          { amount: defaultAmountForIndex(1), label: defaultLabelForIndex(1) },
          { amount: defaultAmountForIndex(2), label: defaultLabelForIndex(2) },
          { amount: defaultAmountForIndex(3), label: defaultLabelForIndex(3) },
          { amount: defaultAmountForIndex(4), label: defaultLabelForIndex(4) }
        ];
    }
  };

  const calcLabel = document.createElement("div");
  calcLabel.textContent = "Single Draw calculator";
  calcLabel.style.marginTop = "2ex";
  root.appendChild(calcLabel);

  const calcControls = document.createElement("form");

  const presetControls = document.createElement("div");
  presetControls.style.border = "solid #888";

  const presetHeading = document.createElement("label");
  presetHeading.textContent = "Preset Controls"
  presetControls.appendChild(presetHeading);

  calcControls.appendChild(presetControls);

  const inDeckInput = document.createElement("input");
  inDeckInput.type = "number";
  inDeckInput.id = "in-deck-input";
  inDeckInput.value = POPULATION_DEFAULT;
  calcControls.appendChild(inDeckInput);

  const inDeckLabel = document.createElement("label");
  inDeckLabel.htmlFor = "in-deck-input";
  inDeckLabel.innerHTML = "In Deck";
  calcControls.appendChild(inDeckLabel);

  const inDeckDefaultWrapper = document.createElement("div");

  const inDeckDefaultInput = document.createElement("input");
  inDeckDefaultInput.type = "number";
  inDeckDefaultInput.id = "in-deck-default-input";
  inDeckDefaultInput.value = POPULATION_DEFAULT;
  inDeckDefaultWrapper.appendChild(inDeckDefaultInput);

  const inDeckDefaultLabel = document.createElement("label");
  inDeckDefaultLabel.htmlFor = "in-deck-default-input";
  inDeckDefaultLabel.textContent = "Default for In Deck";
  inDeckDefaultWrapper.appendChild(inDeckDefaultLabel);

  presetControls.appendChild(inDeckDefaultWrapper);

  const removeClassButton = document.createElement("button");
  removeClassButton.innerHTML = "&nbsp;&nbsp;-&nbsp;&nbsp;";
  removeClassButton.onclick = (e) => {
    e.preventDefault();

    classEntries.pop();

    syncClassEntries();
  };
  presetControls.appendChild(removeClassButton);

  const addClassButton = document.createElement("button");
  addClassButton.innerHTML = "&nbsp;&nbsp;+&nbsp;&nbsp;";
  addClassButton.onclick = (e) => {
    e.preventDefault();

    const i = classEntries.length;

    classEntries.push({ amount: defaultAmountForIndex(i), label: defaultLabelForIndex(i) });
    syncClassEntries();
  };
  presetControls.appendChild(addClassButton);

  // TODO count total in defined classes and whether it is the same as the in deck total
  // TODO list counts of drawn classes
  // TODO a calculator to assess how many unique draws of n cards there are, given different members of a class are considered identical, and order of draws doesn't matter
  //  Huh, doesn't seem to be an easy to find formula for this, at least as I have phrased it

  const classDefaultControlsWrapper = document.createElement("div");
  presetControls.appendChild(classDefaultControlsWrapper);
  const classControlsWrapper = document.createElement("div");
  calcControls.appendChild(classControlsWrapper);

  const classTotalOutput = document.createElement("output");

  presetControls.appendChild(classTotalOutput);

  const defaultAmountForIndex = (i) => {
    switch (i) {
      case 0:
        return 24;
      case 1:
        return 12;
      case 2:
        return 12;
      case 3:
        return 6;
      default:
        return 1;
    }
  };
  const defaultLabelForIndex = (i) => {
    return "Class " + (i + 1);
  };

  let classEntries = loadClassEntriesOrDefault();

  let classElements = [];

  const resetClassControls = () => {
    let previousElements = classElements;
    classElements = [];
    classDefaultControlsWrapper.innerHTML = "";
    classControlsWrapper.innerHTML = "";

    let classMemeberTotal = 0;
    for (let i = 0; i < classEntries.length; i += 1) {
      const wrapper = document.createElement("div");

      const id = i + "-class-input";

      const input = document.createElement("input");
      input.type = "number";
      input.id = id;
      input.value = previousElements[i]?.input?.value || classEntries[i].amount;
      wrapper.appendChild(input);

      const labelElement = document.createElement("input");

      wrapper.appendChild(labelElement);

      classControlsWrapper.appendChild(wrapper);

      const drew = document.createElement("button");

      const defaultWrapper = document.createElement("div");

      const defaultId = i + "-default-input";

      const defaultInput = document.createElement("input");
      defaultInput.type = "number";
      defaultInput.id = defaultId;
      const defaultValue = previousElements[i]?.defaultInput?.value || classEntries[i].amount;
      let defaultValueNumber = parseInt(defaultValue, 10);
      if (!isNaN(defaultValueNumber)) {
        classMemeberTotal += defaultValueNumber;
      } else {
        console.error("defaultValueNumber was NaN!")
      }
      defaultInput.value = defaultValue;

      defaultWrapper.appendChild(defaultInput);
      defaultInput.addEventListener("change", (e) => {
        if (i < classEntries.length) {
          let newValue = parseInt(defaultInput.value, 10);
          if (!isNaN(newValue)) {
            classEntries[i].amount = newValue;
            syncClassEntries();
          }
        }
      });

      const defaultLabel = document.createElement("label");
      defaultLabel.htmlFor = defaultId;
      defaultWrapper.appendChild(defaultLabel);

      classDefaultControlsWrapper.appendChild(defaultWrapper);

      const setLabel = (label) => {
        labelElement.value = label;
        drew.textContent = "drew " + label;
        defaultLabel.textContent = "Default for " + label;
      };

      setLabel(previousElements[i]?.label?.value || classEntries[i].label);
      labelElement.addEventListener("input", (e) => {
        setLabel(labelElement.value);
        renderCalc();
      });
      labelElement.addEventListener("change", (e) => {
        if (i < classEntries.length) {
          classEntries[i].label = labelElement.value;
          syncClassEntries();
        }
      });

      classControlsWrapper.appendChild(drew);
      drew.addEventListener("click", (e) => {
        e.preventDefault();
        input.value -= 1;

        inDeckInput.value -= 1;

        renderCalc()
      });

      classElements.push({input, label: labelElement, defaultInput, defaultLabel});
    }

    let classTotalOutputString = "";
    classTotalOutputString += classMemeberTotal;
    classTotalOutputString += " total class member(s). ";

    const currentDefaultInDeckValue = parseInt(inDeckDefaultInput.value, 10);
    if (isNaN(currentDefaultInDeckValue)) {
      console.error("currentDefaultInDeckValue was NaN")
    } else {
      if (currentDefaultInDeckValue === classMemeberTotal) {
        classTotalOutputString += "All cards in the deck accounted for.";
      } else if (currentDefaultInDeckValue > classMemeberTotal) {
        classTotalOutputString += "Some cards in the deck unaccounted for.";
      } else {
        classTotalOutputString += "That's more than all the cards in the deck!";
      }
    }

    classTotalOutput.textContent = classTotalOutputString
  };
  resetClassControls();

  const calcOutput = document.createElement("pre");

  const formatPercent = (n01) => {
    let output = (n01 * 100).toFixed(5);

    // Check > 1 so "0" gets left alone
    while (output.length > 1 && (output[output.length - 1] === "0")) {
      output = output.slice(0, -1);

      if (output[output.length - 1] === ".") {
        output = output.slice(0, -1);
        break
      }
    }

    return output;
  };

  const renderCalc = () => {
    let popMax = parseInt(inDeckInput.value, 10);
    if (isNaN(popMax)) {
      popMax = POPULATION_DEFAULT;
    }

    calcOutput.textContent = "";

    for (let i = 0; i < classEntries.length; i += 1) {
      const {input, label} = classElements[i];

      let successesInPop = parseInt(input.value, 10);
      if (isNaN(successesInPop)) {
        successesInPop = 0;
      }

      calcOutput.textContent += `${label.value}: ${formatPercent(Hypergeometric.pmf(popMax, successesInPop, 1, 1))}%\n`;
    }
  };

  calcControls.addEventListener("change", renderCalc);

  root.appendChild(calcControls);
  root.appendChild(calcOutput);

  const calcReset = document.createElement("button");
  calcReset.textContent = "Reset to defaults";
  calcReset.style.display = "block";
  calcReset.addEventListener("click", (e) => {
    inDeckInput.value = inDeckDefaultInput.value;

    for (let i = 0; i < classEntries.length; i += 1) {
      const {input, defaultInput} = classElements[i];

      input.value = defaultInput.value;
    }

    renderCalc();
  });
  root.appendChild(calcReset);

  renderCalc();


</script>

</html>
